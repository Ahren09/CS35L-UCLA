{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw17280\paperh25920\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl280\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Useful info to learn python:\
	Dive into python\
	Python official tutorial: \
		https://docs.python.org/3/tutorial/ for python 3\
		or https://docs.python.org/2/tutorial/ for python 2. \
\
0. Why use python:\
	Python is full of Syntactic Sugar \
	(In computer science, syntactic sugar is syntax within a programming \
	language that is designed to make things easier to read or to express. \
	It makes the language "sweeter" for human use: things can be expressed \
	more clearly, more concisely, or in an alternative style that \
	some may prefer.)\
	\
	See the python code examples in the handout and imagine how the code \
	will be like if you're using C++ to do something similar.\
\
1. Hello World in Python:\
\
	#!/usr/bin/python <-- Tells bash how to execute the following program\
	if __name__ == "__main__": <---This defines the main function\
			print "Hello World!"\
	\
	execute python code: \
		python + path_to_your_program\
	or:\
		path_to_your_program\
\
2. How to comment in python:\
	#comments <--- ways to comment one line\
\
	"""\
	This is comment\
	HaHaHa\
	""" \
	Triple quote comments multiple lines\
	\
	Note: \
		They are not really comments. \
		Triple quotes are used to generate strings that span multiple lines. \
		However, if you do not assign these strings to a variable, \
		they have no effects on your code. \
	\
\
		\
3. Variable:\
	In python, there is no explicit variable declarations.  \
	Variables spring into existence by being assigned a value, \
	and they are automatically destroyed when they go out of scope.\
\
	In Python, you never explicitly specify the type of variable. \
	Based on what value you assign, Python keeps track of the type \
	of the variable internally.\
	\
	Example:\
		#!/usr/bin/python \
		if __name__ == "__main__":\
			a = 5   	#a is integer\
			b = 4.0		#b is floating point\
			c = a + b	#c is floating point as b is floating type\
			print c\
			\
	Example 2:\
		#!/usr/bin/python \
		if __name__ == "__main__":\
			print c #python will complain here, as c is not defined. \
\
4. Strings\
	"", '' can be used to quote a string with \
	some subtle differences ("" escape '' while '' escape "") \
	\
	Examples:\
	a="This is a string"\
	b='This is also a string'\
	\
	Strings can be indexed (subscripted), with the first character having \
	index 0. \
	\
	There is no separate character type; a character is simply a string \
	of size 1\
\
	e.g.:\
		word = 'Python'\
		word[0] #'P'\
		word[1] #'y'\
		word[2] = A \
		print word #pyAhon\
		\
	Strings can be concatenated (glued together) with the + operator:\
		'un' + 'ium' # 'unium'\
		\
	In addition to indexing, slicing is also supported. \
	While indexing is used to obtain individual characters, \
	slicing allows you to obtain substring:\
		\
		word = 'Python'\
		word[0:2]  \
		# characters from position 0 (included) to 2 (excluded) 'Py'\
		word[2:5]  \
		# characters from position 2 (included) to 5 (excluded) 'tho'\
		word[:2]   \
		# character from the beginning to position 2 (excluded) 'Py'\
		word[4:]   \
		# characters from position 4 (included) to the end 'on'\
	\
	+---+---+---+---+---+---+\
	| P | y | t | h | o | n |\
	+---+---+---+---+---+---+\
	0   1   2   3   4   5   6\
		\
	len key word returns the length of string\
		word = 'Python'\
		print len(word) # output 6. \
\
	\
5.  Type conversion:\
\
	int convert other types to integer\
	str convert other types to string. \
	\
	a = "123" \
	b = a + 45 #This will fail as string cannot add with a variable\
	b = int(a) + 45 # b is 168\
	c = str(b) + " is the number" #str(b) converts \
			\
6. Code Blocks:\
	Python code blocks have no explicit begin or end, and no curly braces \
	to mark where the function code starts and stops. \
	\
	The only delimiter is a colon (:) and the indentation of the code itself.\
	\
	def factor(n):  #defines a function named factor, with one argument n\
		print 'n =', n\
		if n > 1:	#if statement\
			return n * factor(n \uc0\u8722  1) # factor(n - 1) contains the return value of the function\
		else:	#else\
			print 'end of the function'\
			return 1	#return the value of the function.\
	\
7. Modules: \
	Python does not have header file. \
	To use functions/objects in other file, you need to import it. \
	\
	For example, to call factor in cb.py\
	\
	#!/usr/bin/python \
	import cb\
	if __name__ == "__main__": <---This defines the main function\
			print cb.factor(4)\
			\
	You can also do:\
	from cb import factor \
	#This just import factor from cb.py.\
	#If there is another function named bar in cb.py, \
	#You cannot call bar without importing it. \
	if __name__ == "__main__": <---This defines the main function\
			print factor(4) #Note that you do not need to write cb \
	\
	   \
8. Lists:\
	Array in C++\
	Lists are defined in []\
	Basically, all the opeartions on string can be done on lists. \
	\
	Lists support built-in sorting functions:\
		squares = [5, 3, 2, 4, 1]\
		squares.sort()\
		print squares # [1, 2, 3, 4, 5]\
\
	You can also add new items at the end of the list, by using the append():\
		squares = [1, 4, 9, 16, 25]\
		squares.append(36) # squares =  [1, 4, 9, 16, 36]\
\
	Assignment to slices is also possible:\
		letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\
		letters[2:5] = ['C', 'D', 'E'] \
		print letters # ['a', 'b', 'C', 'D', 'E', 'f', 'g'] \
		\
	Assignment from list to multiple variables:\
		b = [4, 5, 6]\
        i,j,k = b # i = 4, j = 5, k = 6\
		m,n = b[1:] #m = 5, n = 6\
		\
\
9. Print:\
	In python, print things out is easy. Just use print. \
	\
	print variable_you_want_to_print\
	\
	For example:\
		squares = [1, 4, 9, 16, 25]\
		print squares\
	\
	print multiple variables:\
		a = [1, 2, 3]\
		squares = [1, 4, 9, 16, 25]\
		print a, squares\
\
	print string + variable: \
		print "This is squares " + str(squares) \
\
		\
10. If statement:\
\
	if x < 0:\
		x = 0\
		print('Negative changed to zero')\
	elif x == 0:\
		print('Zero')\
	elif x == 1:\
		print('Single')\
	else:\
		print('More')\
	\
	conditional operator:\
		Less than				<\
		Greater than			>\
		Less than or equal		<=\
		Greater than or equal	>=\
		Equals					==\
		Not equal				!=\
		and 					and \
		or 						or\
		not						not \
\
	if (x < 0) or (a == 'aa') and not (c == 5):\
			print 'OK'\
\
\
11.  loops:\
	Python\'92s for statement iterates over the items of any sequence \
	(a list or a string), in the order that they appear in the sequence\
	\
	words = ['cat', 'window', 'defenestrate']\
	for w in words:\
		print(w, len(w))\
		\
	Iterate through numbers:\
		for i in range(1, 5):\
			print i\
	\
	while loop:\
	\
		while condition:\
			code blocks \
\
12. Declare a function:\
	def function_name(arg1, arg2, arg3):\
		code blocks of the function\
		return xxx # returns the value of the function\
		\
	e.g.\
	def factor(n):  	#defines a function named factor, with one argument n\
		print 'n =', n\
		if n > 1:	\
			return n * factor(n \uc0\u8722  1) \
		else:	\
			print 'end of the function'\
			return 1	\
\
13. Command line arguments\
\
	Similar to C++, python has a large number of standard library. \
	import to use them. \
	For example, to get the command line arguments, use the sys module\
	#!/usr/bin/python \
	import sys\
	if __name__ == "__main__": \
			print sys.argv #argv is the list that contains cmd \
						   # line arguments\
						   \
14. Read from file/stdin:\
\
	Read from file:\
		f = open(filename, 'r')\
		lines = f.readlines() \
		# lines is a list containg file content of f. \
		f.close()\
		\
	read from stdin:\
		import sys\
		lines = sys.stdin.readlines()\
		\
15. OptionParser\
\
	Used to parse options passed to the functions. \
	Support short/long options and boolean non-boolean functions. \
	\
	import sys\
\
	if __name__ == "__main__":\
        parser = optparse.OptionParser()\
\
        parser.add_option("-f", action="store", dest="fields")\
		parser.add_option("-n", action="store_true", dest="if_split")\
\
\
        #option is the result after parsing \
        #args is the remaining command line arguments   \
        options, args = parser.parse_args(sys.argv)\
\
		options.field # value of the -f option argument\
		options.if_split # whether -n shows up or not. \
\
\
	\
	\
	\
		\
}